/* * Copyright (c) 2008-2011 by Fuhrer Engineering AG, CH-2504 Biel/Bienne, Switzerland & Bas Leijdekkers * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package tabswitch;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.MouseListener;import java.util.List;import javax.swing.AbstractListModel;import javax.swing.JLabel;import javax.swing.JList;import com.intellij.openapi.components.AbstractProjectComponent;import com.intellij.openapi.fileEditor.FileEditorManager;import com.intellij.openapi.project.Project;import com.intellij.openapi.ui.popup.JBPopup;import com.intellij.openapi.ui.popup.PopupChooserBuilder;import com.intellij.openapi.vfs.VirtualFile;import com.intellij.openapi.wm.WindowManager;import com.intellij.openapi.wm.ex.WindowManagerEx;import tabswitch.component.Components;public class TabSwitchProjectComponent extends AbstractProjectComponent implements KeyEventDispatcher {  private final JList list;  private final PopupChooserBuilder builder;  private JBPopup popup;  private static final int SIZE_X = 300;  private static final int SIZE_Y = 300;  public TabSwitchProjectComponent(Project project) {    super(project);    JLabel pathLabel = Components.newPathLabel();    this.list = Components.newList(project, pathLabel);    this.builder = new PopupChooserBuilder(list);    this.builder      .setTitle("Current tabs")      .setMovable(true)      .setAutoselectOnMouseMove(false)      .setSouthComponent(Components.newListFooter(pathLabel))      .setMinSize(new Dimension(SIZE_X, SIZE_Y))      .setItemChoosenCallback(new Runnable() {        @Override        public void run() {          closeAndOpenSelectedFile();        }      });  }  public static TabSwitchProjectComponent getHandler(Project project) {    return project.getComponent(TabSwitchProjectComponent.class);  }  @Override  public boolean dispatchKeyEvent(KeyEvent event) {    boolean consumed = true;    if (popup != null && popup.isDisposed()) {      KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(this);      consumed = false;    } else if (event.getID() == KeyEvent.KEY_PRESSED) {      int keyCode = event.getKeyCode();      switch (keyCode) {        case KeyEvent.VK_ENTER:          closeAndOpenSelectedFile();          break;        case KeyEvent.VK_ESCAPE:          close();          break;        default:          break;      }    }    return consumed;  }  public void show(List<VirtualFile> files) {    if (cannotShow(files)) {      return;    }    if (popup != null) {      popup.dispose();    }    prepareListWithFiles(files);    popup = builder.createPopup();    KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(this);    Rectangle parentScreen = this.getWindow(myProject).getBounds();    int x = parentScreen.x + (parentScreen.width / 2) - (SIZE_X / 2);    int y = (int)(parentScreen.y + (parentScreen.height / 2.5) - (SIZE_Y / 2));    popup.showInScreenCoordinates(this.getWindow(myProject), new Point(x, y));  }  private Window getWindow(Project project) {    WindowManagerEx windowManager = (WindowManagerEx) WindowManager.getInstance();    return windowManager.getFrame(project);  }  private boolean cannotShow(List<VirtualFile> files) {    return files.isEmpty() || popup != null && popup.isVisible();  }  private void prepareListWithFiles(final List<VirtualFile> files) {    list.setModel(new AbstractListModel() {      @Override      public int getSize() {        return files.size();      }      @Override      public Object getElementAt(int index) {        return files.get(index);      }    });    list.setVisibleRowCount(files.size());  }  public void closeAndOpenSelectedFile() {    close();    openSelectedFile();  }  private void close() {    disposePopup();    removeMouseListeners();    KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(this);  }  private void openSelectedFile() {    VirtualFile file = (VirtualFile) list.getSelectedValue();    if (file != null && file.isValid()) {      FileEditorManager.getInstance(myProject).openFile(file, true, true);    }  }  private void disposePopup() {    if (popup != null) {      popup.cancel();      popup.dispose();      popup = null;    }  }  /**   * Workaround for MouseListener leak added in PopupChooserBuilder.createPopup().   */  private void removeMouseListeners() {    for (MouseListener listener : list.getMouseListeners()) {      removeMouseListener(listener);    }  }  private void removeMouseListener(MouseListener listener) {    if (listener.getClass().getName().startsWith("com.intellij.openapi.ui.popup.PopupChooserBuilder")) {      list.removeMouseListener(listener);    }  }}